:description: This section describes the Bolt Protocol message specification.

= Bolt Protocol message specification

The message specification describes the message exchanges that take place on a connection following a successful Bolt handshake.
For details of establishing a connection and performing a handshake, see xref:bolt/handshake.adoc[].

The Bolt protocol communicates with specific versioned messages.

== Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime.
This state is used to determine what actions may be undertaken by the client.

For more information, see the corresponding version of the xref:bolt/server-state.adoc[].

[[server-signals]]
===  Server signals

_Jump ahead_ means that the signal is immediately available before any messages are processed in the message queue.

[cols="<,^,<",options="header"]
|===
| Server signal
| Jump ahead
| Description

| `<INTERRUPT`>
| X
| an interrupt signal

| `<DISCONNECT>`
|
| a disconnect signal
|===

[[protocol-errors]]
=== Protocol errors

If a server or client receives a message type that is unexpected, according to the transitions described in this document, it must treat that as a protocol error.
Protocol errors are fatal and should immediately transition the server state to `DEFUNCT`, closing any open connections.

[[session]]
=== Session

Each connection to the server creates a new *session* that lives until that connection is closed.
Each session is isolated and the server keeps track of the current state, based on the requests and responses exchanged within that session.
A session ends when the socket for that connection is closed.
Typically, this will be closed by the client.

[[message-exchange]]
== Message exchange

Messages are exchanged in a request-response pattern between client and server.
Each request consists of exactly one message and each response consists of zero or more detail messages followed by exactly one summary message.
The presence or absence of detail messages in a response is directly related to the type of request message that has been sent.
In other words, some request message types elicit a response that may contain detail messages, others do not.

Messages may also be pipelined. In other words, clients may send multiple requests eagerly without first waiting for responses.
When a failure occurs in this scenario, servers *must* ignore all subsequent requests until the client has explicitly acknowledged receipt of the failure.
This prevents inadvertent execution of queries that may not be valid.
More details of this process can be found in the sections below.

[[serialization]]
=== Serialization

Messages and their contents are serialized into network streams using xref:packstream/index.adoc[PackStream Specification Version 1].
*Each message is represented as a PackStream structure* that contains a fixed number of fields.
The message type is denoted by the PackStream structure *tag byte* and each message is defined in the Bolt protocol.
*Serialization is specified with PackStream Version 1*.

[[chunking]]
=== Chunking

A layer of chunking is also applied to message transmissions as a way to more predictably manage packets of data.
The chunking process allows the message to be broken into one or more pieces, each of an arbitrary size, and for those pieces to be transmitted within separate chunks.
Each chunk consists of a *two-byte header*, detailing the chunk size in bytes followed by the chunk data itself.
Chunk headers are *16-bit unsigned integers*, meaning that the maximum theoretical chunk size permitted is 65,535 bytes.

Each encoded message must be terminated with a chunk of zero size, i.e.
----
00 00
----

This is used to signal message boundaries to a receiving parties, allowing blocks of data to be fully received without requiring that the message is parsed immediately.
This also allows for unknown message types to be received and handled without breaking the messaging chain.

The Bolt protocol encodes each message using a chunked transfer encoding.
** Each message is transferred as one or more chunks of data.
** Each chunk starts with a two-byte header, an unsigned big-endian 16-bit integer, representing the size of the chunk not including the header.
** A message can be divided across multiple chunks, allowing client and server alike to transfer large messages without having to determine the length of the entire message in advance.
** Chunking applies on each message individually.
** One chunk cannot contain more than one message.
** Each message ends with two bytes with the value 00 00, these are not counted towards the chunk size (you may consider them as individual chunks of size 0).

==== Examples of how Bolt chunks messages

.Example of a message in one chunk
Message data containing 16 bytes:
----
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----
results in the following chunk:
----
00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
----
with the chunk header `00 10` and the end marker `00 00`.

.Example of a message split in two chunks
Message data containing 20 bytes:
----
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 01 02 03 04
----
results in chunk 1 and chunk 2:
----
00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00 04 01 02 03 04 00 00
----
with the chunk 1 header `00 01` and no end marker for chunk 1, still message data.
Chunk 2 has a header `00 04` and an end marker `00 00`.

.Example with two messages
Message 1 data containing 16 bytes:
----
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----
Message 2 data containing 8 bytes:
----
0F 0E 0D 0C 0B 0A 09 08
----
are both encoded with chunking:
----
00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00
----

[[pipelining]]
=== Pipelining

The client may send multiple requests eagerly without first waiting for responses.


[[transaction]]
=== Transaction

A transaction is the concept of atomic units of work.

The concept of *Transaction* is when the server is in the `READY` state and the transaction is opened with the request message `RUN` and the response of a summary message `SUCCESS`.
The *Transaction* is successfully closed with the summary message `SUCCESS` for the request message `PULL_ALL` or the request message `DISCARD_ALL`.

*Version 3* of the Bolt Protocol introduces the concept of *Auto-commit Transaction* and *Explicit Transaction*.
*Auto-commit Transaction* is the server in the `READY` state and the transition to the `STREAMING` state.
The transaction is opened with the request message `RUN` and the response of a summary message `SUCCESS`.

The *Auto-commit Transaction* is successfully closed with the summary message `SUCCESS` for the request message `PULL_ALL` or the request message `DISCARD_ALL`.
Thus the *Auto-commit Transaction* can only contain one `RUN` request message.

In *version 4* of the Bolt Protocol, the `DISCARD_ALL` and `PULL_ALL` messages are renamed to `DISCARD` and `PULL` and new fields are introduced.

.Example with Bolt v4
----
...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: RUN ...      // Open a new Auto-commit Transaction
S: SUCCESS ...  // Server is in STREAMING state

C: PULL ...
S: RECORD ...
   ...
S: RECORD ...
S: SUCCESS ... has_more=true  // Server is still in STREAMING state

C: PULL
S: RECORD ...
   ...
S: RECORD ...
S: SUCCESS ... has_more=false  // Server is in READY state and this implies that the Auto-commit Transaction is closed.
----

[NOTE]
====
In version 1, `HELLO` is called `INIT` and Auto-commit Transaction is just Transaction.
The field `has_more=true/false` is introduced in version 4.
See also the corresponding version of the xref:bolt/server-state.adoc[].
====

The *Explicit Transaction* is introduced in *version 3* of Bolt and is a more generic transaction that can contain several `RUN` request messages.
The concept of *Explicit Transaction* is when the server is in the `READY` state and the transaction is opened with the request message `BEGIN` and the response of a summary message `SUCCESS` (thus transition into the `TX_READY` server state).

The *Explicit Transaction* is successfully closed with the request message `COMMIT` and the response of a summary message `SUCCESS`.
The result stream (detail messages) must be fully consumed or discarded by a client before the server can transition to the `TX_READY` state and thus be able to close the transaction with a `COMMIT` request message.
It can be gracefully discarded and set to the initial server state of `READY` with the request message `ROLLBACK`.

.Example with Bolt v4
----
...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: BEGIN ...    // Open a new Explicit Transaction
S: SUCCESS ...  // Server is in TX_READY state

C: RUN ...
S: SUCCESS ... qid=123 // Server is in TX_STREAMING state, one stream is open

C: RUN ...
S: SUCCESS ... qid=456 // Server is in TX_STREAMING state, two streams are open

C: PULL ... qid=123
S: RECORD ...
   ...
S: RECORD ...
S: SUCCESS ... has_more=true  // Server is still in TX_STREAMING state, two streams are still open

C: PULL ... qid=123
S: RECORD ...
   ...
S: RECORD ...
S: SUCCESS ... has_more=false  // Server is still in TX_STREAMING state, one stream is still open

C: PULL ... qid=456
S: RECORD ...
   ...
S: RECORD ...
S: SUCCESS ... has_more=false  // Server is in TX_READY state, all streams have been fully consumed

C: COMMIT   // Close the Explicit Transaction
S: SUCCESS  // Server is in READY state
----

[NOTE]
====
In version 3, `PULL` is called `PULL_ALL`.
Additionally, there are no fields, e.g `qid=123` and `has_more=true/false` available in version 3 of the Bolt Protocol.
====

[[messages]]
== Messages

There are three different kinds of messages:

** *Request message* - the client sends a message.
** *Summary message* - the server always responds with one summary message if the connection is still open.
** *Detail message* - the server always responds with zero or more detail messages before sending a summary message.

[cols="<15,^10,<10,<40,<30",options="header"]
|===
| Message
| Signature
| Type of message
| Fields
| Description

| <<messages-hello, `HELLO`>>
| `01`
| Request
| `extra::Dictionary(user_agent::String, scheme::String, routing::Dictionary(address::String))`
| initialize connection (replaces <<messages-init, `INIT`>> of v1 & v2)(`routing::Dictionary(address::String)` added in 4.1)

| <<messages-goodbye, `GOODBYE`>>
| `02`
| Request
|
| close the connection, triggers a `<DISCONNECT>` signal

| <<messages-ack-failure, `ACK_FAILURE`>> (only v1 and v2)
| `0E`
| Request
|
| acknowledge a failure response (deprecated, use `RESET` instead with v3+)

| `RESET`
| `0F`
| Request
|
| reset the connection, triggers a `<INTERRUPT>` signal

| `RUN`
| `10`
| Request
| `query::String, parameters::Dictionary, extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::Stringdb:String)`
| execute a query (`db:String` added in v4.0)

| `DISCARD`
| `2F`
| Request
| `extra::Dictionary(n::Integer, qid::Integer)`
| discard records (replaces `DISCARD_ALL` of v1, v2 & v3)(fields added in v4.0)

|`PULL`
| `3F`
| Request
| `extra::Dictionary(n::Integer, qid::Integer)`
| fetch records (replaces `PULL_ALL` of v1, v2 & v3)(fields added in v4.0)

| `BEGIN`
| `11`
| Request
| `extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db::String, imp_user::String)`
| begin a new transaction (added in v3)(`db::String, imp_user::String` added in v4.0)

| `COMMIT`
| `12`
| Request
|
| commit a transaction (added in v3)

| `ROLLBACK`
| `13`
| Request
|
| rollback a transaction (added in v3)

| `ROUTE`
| `66`
| Request
| `routing::Dictionary(address::String), bookmarks::List<String>, extra::Dictionary(db::String, imp_user::String)`
| fetch the current routing table

| `SUCCESS`
| `70`
| Summary
| `metadata::Dictionary`
| request succeeded

| `IGNORED`
| `7E`
| Summary
|
| request was ignored

| `FAILURE`
| `7F`
| Summary
| `metadata::Dictionary(code::String, message::String)`
| request failed

| `RECORD`
| `71`
| Detail
| `data::List`
| data values
|===

[[messages-hello]]
=== Request message - `HELLO`

The `HELLO` message request the connection to be authorized for use with the remote database and replaces the `INIT` request message of version 1 and 2.
See below for more information on `INIT`.

The server must be in the `CONNECTED` state to be able to process a `HELLO` message.
For any other states, receipt of an `HELLO` request must be considered a protocol violation and lead to connection closure.

Clients should send `HELLO` message to the server immediately after connection and process the corresponding response before using that connection in any other way.
If authentication fails, the server must respond with a `FAILURE` message and immediately close the connection.

Clients wishing to retry initialization should establish a new connection.

The `routing::Dictionary(address::String)` field is added in version *4.1* and adds an indicator if the server should carry out routing, according to the the given routing context.

[cols="<30,<40",option="header"]
|===
| `routing` values
| Description

| {"routing": null} or {}
| the server should not carry out routing

| {"routing: {}}
| the server should carry out routing

| {"routing: {"address": "x.example.com:9001", "region": "example", ...}}
| the server should carry out routing according to the given routing context
|===

*Signature:* `01`

*Fields:*
----
extra::Dictionary(
  user_agent::String,
  scheme::String,
  routing::Dictionary(address::String),
  â€¦
)
----

** The `user_agent` should conform to `"Name/Version"` for example `"Example/4.1.0"` (see link:developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent[] for more information).
** The scheme is the authentication scheme.
Predefined schemes are `"none"`, `"basic"`, and `"kerberos"`.
** The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. `"x.example.com:9001"`.
Key-value entries in the routing context should correspond exactly to those in the original URI query string.
Setting `routing` to `null` indicates that the server should not carry out any routing.
Default: `null`.
** Further entries in extra are passed to the implementation of the chosen authentication scheme.
Their names, types, and defaults depend on that choice.
*** The scheme `"basic"` requires a user name `principal::String` and a password `credentials::String`.
*** The scheme `"bearer"` merely requires a token `credentials::String` (added in version *4.4*).

*Detail messages:*

No detail messages should be returned.

*Valid summary messages:*

** `SUCCESS`
** `FAILURE`

==== Synopsis

----
HELLO {user_agent::String, scheme::String, routing::Dictionary(address::String))
----

.Example 1
----
HELLO {"user_agent": "Example/4.1.0", "scheme": "basic", "principal": "user", "credentials": "password", "routing": {"address": "x.example.com:9001"}}
----

.Example 2
----
HELLO {"user_agent": "Example/4.1.0", "scheme": "basic", "principal": "user", "credentials": "password", "routing": {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"}}
----

==== Server response `SUCCESS`

A `SUCCESS` message response indicates that the client is permitted to exchange further messages.
Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the `SUCCESS` metadata:

** `server::String` (server agent string, example `"Neo4j/4.1.0"`)
** `connection_id::String` (unique identifier of the bolt connection used on the server side, example: `"bolt-61"`)
** `hints::Dictionary` (set of optional configuration hints to be considered by the driver)

The `hints` dictionary is introduced in version *4.3* and may contain a set of optional configuration hints which may be interpreted or ignored by drivers at their own discretion in order to augment operations where applicable.
A full listing of the available hints may be found in Appendix B.
Hints remain valid throughout the lifetime of a given connection and cannot be changed.
As such, newly established connections may observe different hints and/or hint values as the server configuration is adjusted.

.Example
----
SUCCESS {"server": "Neo4j/4.0.0", "hints": {"connection.recv_timeout_seconds": 120}}
----

==== Server response `FAILURE`

A `FAILURE` message response indicates that the client is not permitted to exchange further messages.
Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.

.Example
----
FAILURE {"code": "Example.Failure.Code", "message": "example failure"}
----

[[messages-init]]
=== Request message `INIT`

*The request message `INIT` is only valid in version 1 and 2 and is replaced by the request message `HELLO` in version 3+.*
_The `INIT` message is a request for the connection to be authorized for use with the remote database._

_The `INIT` message uses the structure signature `01` and passes two fields: `user agent` (String) and `auth_token` (Dictionary)._

_The server must be in the `CONNECTED` state to be able to process an `INIT` request._
_For any other states, receipt of an `INIT` request must be considered a protocol violation and lead to connection closure._

_Clients should send `INIT` requests to the network immediately after connection and process the corresponding response before using that connection in any other way._

_A receiving server may choose to register or otherwise log the user agent but may also ignore it if preferred._

_The auth token should be used by the server to determine whether the client is permitted to exchange further messages._
_If this authentication fails, the server must respond with a `FAILURE` message and immediately close the connection._
_Clients wishing to retry initialization should establish a new connection._

_*Signature:*_ `01`
_*Fields:*_
----
user_agent::String,
auth_token::Dictionary(
  scheme::String,
  principal::String,
  credentials::String,
)
----

** _The `user_agent` should conform to `"Name/Version"` for example `"Example/1.1.0"` (see link:developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent[] for more information)._
** _The `scheme` is the authentication scheme._
_Predefined schemes are `"none"` and `"basic"`._
_If no `scheme` is provided, it defaults to `"none"`._
** _The `auth_token` must contain either just the entry `{"scheme" : "none"}` or the keys `scheme`, `principal` and `credentials`._

_*Detail messages:*_
_No detail messages should be returned._

_*Valid Summary Messages:_*

** `SUCCESS`
** `FAILURE`

==== _Synopsis_

----
INIT "user_agent" {auth_token}
----

.Example 1
----
INIT "Example/1.0.0" {"scheme": "none"}
----

.Example 2
----
INIT "Example/1.0.0" {"scheme": "basic", "principal": "neo4j", "credentials": "password"}
----

==== _Server response `SUCCESS`_

_A `SUCCESS` message response indicates that the client is permitted to exchange further messages._
_Servers can include metadata that describes details of the server environment and/or the connection._

_The following fields are defined for inclusion in the `SUCCESS` metadata._

** _`server (e.g. `"Neo4j/3.4.0"`)_

.Example
----
SUCCESS {"server": "Neo4j/3.4.0"}
----

==== _Server response `FAILURE`_

_A `FAILURE` message response indicates that the client is not permitted to exchange further messages._

_Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent._

.Example
----
FAILURE {"code": "Example.Failure.Code", "message": "example failure"}
----

[[messages-goodbye]]
=== Request message `GOODBYE`

The `GOODBYE` message is introduced in version *3* and notifies the server that the connection is terminating gracefully.
On receipt of this message, the server should immediately shut down the socket on its side without sending a response.

A client may shut down the socket at any time after sending the `GOODBYE` message.
This message interrupts the server current work if there is any.

*Signature:* `02`

*Fields:*

No fields.

*Detail messages:*

No detail messages should be returned.

*Valid summary messages:*

No summary messages should be returned.

==== Synopsis

----
GOODBYE
----

.Example
----
GOODBYE
----

[[messages-ack-failure]]
=== Request message `ACK_FAILURE`

*The request message `ACK_FAILURE` is only valid in version 1 and 2 and the request message `RESET` should be used in its place in version 3+.*

_The request message `ACK_FAILURE` signals to the server that the client has acknowledged a previous failure and should return to a `READY` state._

_*Signature:*_ `0E`

_*Fields:*_

_No fields._

_Detail messages:_

_No detail messages should be returned._

_*Valid summary messages:*_

** `SUCCESS`
** `FAILURE`

_The server must be in a `FAILED` state to be able to successfully process an `ACK_FAILURE` request._
_For any other states, receipt of an `ACK_FAILURE` request will be considered a protocol violation and will lead to connection closure._

==== _Synopsis_

----
ACK_FAILURE
----

.Example
----
ACK_FAILURE
----

==== _Server response `SUCCESS`_

_If an `ACK_FAILURE` request has been successfully received, the server should respond with a `SUCCESS` message and enter the `READY` state._

_The server may attach metadata to the `SUCCESS` message._

.Example
----
SUCCESS {}
----

==== _Server response message `FAILURE`_

_If an `ACK_FAILURE` request is received while not in the `FAILED` state, the server should respond with a `FAILURE` message and immediately close the connection._

_The server may attach metadata to the message to provide more detail on the nature of the failure._

.Example
----
FAILURE {"code": "Example.Failure.Code", "message": "example failure"}
----
